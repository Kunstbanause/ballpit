<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball x Pit</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef } = React;

        const jsonData = {
          "evolutions": [
            {
              "name": "Vampire Lord",
              "ingredients": ["Bleed", "Vampire"],
              "category": "Bleed",
              "description": "Each hit inflicts 3 stacks of bleed. Heals 1 health and consumes all stacks when hitting an enemy with at least 10 stacks of bleed"
            },
            {
              "name": "Leech",
              "ingredients": ["Bleed", "Brood Mother"],
              "category": "Bleed",
              "description": "Attaches up to 1 leech onto enemies it hits, which adds 2 stacks of bleed per second (max 24 stacks)"
            },
            {
              "name": "Virus",
              "ingredients": ["Bleed", "Poison"],
              "category": "Bleed",
              "description": "Applies 1 stack of disease to units it hits (max 8 stacks). Disease lasts for 6 seconds. Each stack of disease deals 3-6 damage per second and diseased units have a 15% chance of passing a stack to undiseased nearby enemies each second"
            },
            {
              "name": "Berserk",
              "ingredients": ["Bleed", "Charm"],
              "category": "Bleed",
              "description": "Each hit has a 30% chance of causing enemies to go berserk for 6 seconds. Berserk enemies deal 15-24 damage to adjacent enemies every second"
            },
            {
              "name": "Sacrifice",
              "ingredients": ["Bleed", "Dark"],
              "category": "Bleed",
              "description": "Inflicts 4 stacks of bleed (max 15 stacks) and applies curse to hit enemies. Cursed enemies are dealt 50-100 after being hit 5 times"
            },
            {
              "name": "Hemorrhage",
              "ingredients": ["Bleed", "Iron"],
              "category": "Bleed",
              "description": "Inflicts 3 stacks of bleed. When hitting an enemy with 12 stacks of bleed or more, consume all stacks of bleed to deal 20% of their current health"
            },
            {
              "name": "Leech",
              "ingredients": ["Brood Mother", "Bleed"],
              "category": "Brood Mother",
              "description": "Attaches up to 1 leech on to enemies it hits, which adds 2 stacks of bleed per second (max 24 stacks)"
            },
            {
              "name": "Maggot",
              "ingredients": ["Brood Mother", "Cell"],
              "category": "Brood Mother",
              "description": "Infest enemies on hit with maggots. When they die, they explode into 1-2 baby balls"
            },
            {
              "name": "Spider Queen",
              "ingredients": ["Brood Mother", "Egg Sac"],
              "category": "Brood Mother",
              "description": "Has a 25% chance of birthing an Egg Sac each time it hits an enemy"
            },
            {
              "name": "Mosquito King",
              "ingredients": ["Brood Mother", "Vampire"],
              "category": "Brood Mother",
              "description": "Spawns a mosquito each time it hits an enemy. Mosquitos attack a random enemy, dealing 80-120 damage each. If a mosquito kills an enemy, they steal 1 health"
            },
            {
              "name": "Bomb",
              "ingredients": ["Burn", "Iron"],
              "category": "Burn",
              "description": "Explodes when hitting an enemy, dealing 150-300 damage to nearby enemies. Has a 3-second cooldown before it can be shot again"
            },
            {
              "name": "Magma",
              "ingredients": ["Burn", "Earthquake"],
              "category": "Burn",
              "description": "Emits lava blobs over time. Enemies who walk into lava blobs are dealt 15-30 damage and gain 1 stack of burn (max 3 stacks). Burn lasts for 3 seconds, dealing 3-8 damage per stack per second. This ball and its lava blobs also deal 6-12 damage to nearby units"
            },
            {
              "name": "Inferno",
              "ingredients": ["Burn", "Wind"],
              "category": "Burn",
              "description": "Applies 1 stack of burn every second to all enemies within a 2 tile radius. Burn lasts for 6 seconds, dealing 3-7 damage per stack per second"
            },
            {
              "name": "Berserk",
              "ingredients": ["Burn", "Charm"],
              "category": "Burn",
              "description": "Each hit has a 30% chance of causing enemies to go berserk for 6 seconds. Berserk enemies deal 15-24 damage to adjacent enemies every second"
            },
            {
              "name": "Sun",
              "ingredients": ["Burn", "Light"],
              "category": "Burn",
              "description": "Blind all enemies in view and add 1 stack of burn every second (max 5 stacks). Burn lasts for 6 seconds and deals 6-12 damage per stack per second"
            },
            {
              "name": "Frozen Flame",
              "ingredients": ["Burn", "Freeze"],
              "category": "Burn",
              "description": "Add 1 stack of frostburn on hit for 20 seconds (max 4 stacks). Frostburnt units are dealt 8-12 damage per stack per second and receive 25% more damage from other sources"
            },
            {
              "name": "Maggot",
              "ingredients": ["Cell", "Brood Mother"],
              "category": "Cell",
              "description": "Infest enemies on hit with maggots. When they die, they explode into 1-2 baby balls"
            },
            {
              "name": "Overgrowth",
              "ingredients": ["Cell", "Earthquake"],
              "category": "Cell",
              "description": "Applies 1 stack of overgrowth. Upon reaching 3, consume all stacks and deal 0-200 damage to all enemies in a 3x3 tile square"
            },
            {
              "name": "Radiation Beam",
              "ingredients": ["Cell", "Laser"],
              "category": "Cell",
              "description": "Emit a radiation beam on hit that deals 24-48 damage and applies 1 stack of radiation (max 5 stacks). Radiation lasts for 15 seconds and causes enemies to receive 10% more damage from all sources per stack"
            },
            {
              "name": "Virus",
              "ingredients": ["Cell", "Poison"],
              "category": "Cell",
              "description": "Applies 1 stack of disease to units it hits (max 8 stacks). Disease lasts for 6 seconds. Each stack of disease deals 3-6 damage per second and diseased units have a 15% chance of passing a stack to undiseased nearby enemies each second"
            },
            {
              "name": "Succubus",
              "ingredients": ["Charm", "Vampire"],
              "category": "Charm",
              "description": "Each hit has a 4% chance of charming the enemy for 9 seconds. Heals 1 when hitting a charmed enemy"
            },
            {
              "name": "Berserk",
              "ingredients": ["Charm", "Burn"],
              "category": "Charm",
              "description": "Each hit has a 30% chance of causing enemies to go berserk for 6 seconds. Berserk enemies deal 15-24 damage to adjacent enemies every second"
            },
            {
              "name": "Incubus",
              "ingredients": ["Charm", "Dark"],
              "category": "Charm",
              "description": "Each hit has a 4% chance of charming the enemy for 9 seconds. Charmed enemies curse nearby enemies. Cursed enemies are dealt 100-200 after being hit 5 times"
            },
            {
              "name": "Lovestruck",
              "ingredients": ["Charm", "Light"],
              "category": "Charm",
              "description": "Inflicts lovestruck on hit enemies for 20 seconds. Lovestruck units have a 50% chance of healing you for 5 health when they attack"
            },
            {
              "name": "Vampire Lord",
              "ingredients": ["Dark", "Vampire"],
              "category": "Dark",
              "description": "Each hit inflicts 3 stacks of bleed. Heals 1 health and consumes all stacks when hitting an enemy with at least 10 stacks of bleed"
            },
            {
              "name": "Assassin",
              "ingredients": ["Dark", "Iron"],
              "category": "Dark",
              "description": "Passes through the front of enemies, but not the back. Backstabs deal 30% bonus damage"
            },
            {
              "name": "Phantom",
              "ingredients": ["Dark", "Ghost"],
              "category": "Dark",
              "description": "Curse enemies on hit. Cursed enemies are dealt 100-200 damage after being hit 5 times"
            },
            {
              "name": "Sacrifice",
              "ingredients": ["Dark", "Bleed"],
              "category": "Dark",
              "description": "Inflicts 4 stacks of bleed (max 15 stacks) and applies curse on hit to enemies. Cursed enemies are dealt 50-100 after being hit 5 times"
            },
            {
              "name": "Incubus",
              "ingredients": ["Dark", "Charm"],
              "category": "Dark",
              "description": "Each hit has a 4% chance of charming the enemy for 9 seconds. Charmed enemies curse nearby enemies. Cursed enemies are dealt 100-200 after being hit 5 times"
            },
            {
              "name": "Black Hole",
              "ingredients": ["Dark", "Sun"],
              "category": "Dark",
              "description": "Instantly kills the first non-boss enemy that it hits, but destroys itself afterwards. Has a 7-second cooldown before it can be shot again"
            },
            {
              "name": "Noxious",
              "ingredients": ["Dark", "Wind"],
              "category": "Dark",
              "description": "Passes through enemies and applies 3 stacks of poison to nearby enemies within a 2 tile radius. Poison lasts for 4 seconds and each stack deals 1-3 damage per second"
            },
            {
              "name": "Flicker",
              "ingredients": ["Dark", "Light"],
              "category": "Dark",
              "description": "Deals 1-7 damage to every enemy on screen ever 1.4 seconds"
            },
            {
              "name": "Magma",
              "ingredients": ["Earthquake", "Burn"],
              "category": "Earthquake",
              "description": "Emits lava blobs over time. Enemies who walk into lava blobs are dealt 15-30 damage and gain 1 stack of burn (max 3 stacks). Burn lasts for 3 seconds, dealing 3-8 damage per stack per second. This ball and its lava blobs also deal 6-12 damage to nearby units"
            },
            {
              "name": "Swamp",
              "ingredients": ["Earthquake", "Poison"],
              "category": "Earthquake",
              "description": "Leaves behind tar blobs over time. Enemies who walk into tar blobs are dealt 15-30, are slowed by 50% for 7 seconds and gain 1 stack of poison (max 8 stacks). Each stack of poison deals 1-3 damage per second. This ball and its tar blobs also deal 6-12 damage to nearby units"
            },
            {
              "name": "Glacier",
              "ingredients": ["Earthquake", "Freeze"],
              "category": "Earthquake",
              "description": "Releases glacial spikes over time that deal 15-30 damage to enemies that touch them and freeze them for 2.0 seconds. This ball and its glacial spikes also deal 6-12 damage to nearby units"
            },
            {
              "name": "Sandstorm",
              "ingredients": ["Earthquake", "Wind"],
              "category": "Earthquake",
              "description": "Goes through enemies and is surrounded by a raging storm dealing 10-20 damage per second and blinding nearby enemies for 3 seconds"
            },
            {
              "name": "Overgrowth",
              "ingredients": ["Earthquake", "Cell"],
              "category": "Earthquake",
              "description": "Applies 1 stack of overgrowth. Upon reaching 3, consume all stacks and deal 0-200 damage to all enemies in a 3x3 tile square"
            },
            {
              "name": "Spider Queen",
              "ingredients": ["Egg Sac", "Brood Mother"],
              "category": "Egg Sac",
              "description": "Has a 25% chance of birthing an Egg Sac each time it hits an enemy"
            },
            {
              "name": "Mosquito Swarm",
              "ingredients": ["Egg Sac", "Vampire"],
              "category": "Egg Sac",
              "description": "Explodes into 3-6 mosquitoes. Mosquitos attack random enemies, dealing 80-120 damage each. If a mosquito kills an enemy, they steal 1 health"
            },
            {
              "name": "Shotgun",
              "ingredients": ["Egg Sac", "Iron"],
              "category": "Egg Sac",
              "description": "Shoots 3-7 iron baby balls after hitting a wall. Iron baby balls move at 200% speed but are destroyed upon hitting anything"
            },
            {
              "name": "Voluptuous Egg Sac",
              "ingredients": ["Egg Sac", "Cell"],
              "category": "Egg Sac",
              "description": "Explodes into 2-3 egg sacs on hitting an enemy. Has a 3-second cooldown before it can be shot again"
            },
            {
              "name": "Wraith",
              "ingredients": ["Freeze", "Ghost"],
              "category": "Freeze",
              "description": "Freezes any enemy it passes through for 0.8 seconds"
            },
            {
              "name": "Blizzard",
              "ingredients": ["Freeze", "Lightning"],
              "category": "Freeze",
              "description": "Freezes all enemies within a 2 tile radius for 0.8 seconds, dealing 1-50 damage"
            },
            {
              "name": "Freeze Ray",
              "ingredients": ["Freeze", "Laser"],
              "category": "Freeze",
              "description": "Emits a freeze ray when hitting an enemy, dealing 20-50 to all enemies in its path, with a 10% chance of freezing them for 10.0 seconds"
            },
            {
              "name": "Frozen Flame",
              "ingredients": ["Freeze", "Burn"],
              "category": "Freeze",
              "description": "Add 1 stack of frostburn on hit for 20 seconds (max 4 stacks). Frostburnt units are dealt 8-12 damage per stack per second and receive 25% more damage from other sources"
            },
            {
              "name": "Glacier",
              "ingredients": ["Freeze", "Earthquake"],
              "category": "Freeze",
              "description": "Releases glacial spikes over time that deal 15-30 to enemies that touch them and freeze them for 2.0 seconds. This ball and its glacial spikes also deal 6-12 damage to nearby units"
            },
            {
              "name": "Wraith",
              "ingredients": ["Ghost", "Freeze"],
              "category": "Ghost",
              "description": "Freezes any enemy it passes through for 0.8 seconds"
            },
            {
              "name": "Assassin",
              "ingredients": ["Ghost", "Iron"],
              "category": "Ghost",
              "description": "Passes through the front of enemies, but not the back. Backstabs deal 30% bonus damage"
            },
            {
              "name": "Virus",
              "ingredients": ["Ghost", "Poison"],
              "category": "Ghost",
              "description": "Applies 1 stack of disease to units it hits (max 8 stacks). Disease lasts for 6 seconds. Each stack of disease deals 3-6 damage per second and diseased units have a 15% chance of passing a stack to undiseased nearby enemies each second"
            },
            {
              "name": "Phantom",
              "ingredients": ["Ghost", "Dark"],
              "category": "Ghost",
              "description": "Curse enemies on hit. Cursed enemies are dealt 100-200 damage after being hit 5 times"
            },
            {
              "name": "Soul Sucker",
              "ingredients": ["Ghost", "Vampire"],
              "category": "Ghost",
              "description": "Passes through enemies and saps them, with a 30% chance of stealing 1 health and reducing their attack damage by 20%. Lifesteal chance only applies once per enemy"
            },
            {
              "name": "Bomb",
              "ingredients": ["Iron", "Burn"],
              "category": "Iron",
              "description": "Explodes when hitting an enemy, dealing 150-300 damage to nearby enemies. Has a 3-second cooldown before it can be shot again"
            },
            {
              "name": "Assassin",
              "ingredients": ["Iron", "Ghost"],
              "category": "Iron",
              "description": "Passes through the front of enemies, but not the back. Backstabs deal 30% bonus damage"
            },
            {
              "name": "Lightning Rod",
              "ingredients": ["Iron", "Lightning"],
              "category": "Iron",
              "description": "Plants a lightning rod into enemies it hits. These enemies are struck by lightning every 3.0 seconds, dealing 1-30 damage to up to 8 nearby enemies"
            },
            {
              "name": "Shotgun",
              "ingredients": ["Iron", "Egg Sac"],
              "category": "Iron",
              "description": "Shoots 3-7 iron baby balls after hitting a wall. Iron baby balls move at 200% speed but are destroyed upon hitting anything"
            },
            {
              "name": "Hemorrhage",
              "ingredients": ["Iron", "Bleed"],
              "category": "Iron",
              "description": "Inflicts 3 stacks of bleed. When hitting an enemy with 12 stacks of bleed or more, consumes all stacks of bleed to deal 20% of their current health"
            },
            {
              "name": "Holy Laser",
              "ingredients": ["Laser (Horizontal)", "Laser (Vertical)"],
              "category": "Laser",
              "description": "Deals 24-36 damage to all enemies in the same row and column"
            },
            {
              "name": "Freeze Ray",
              "ingredients": ["Laser", "Freeze"],
              "category": "Laser",
              "description": "Emits a freeze ray when hitting an enemy, dealing 20-50 to all enemies in its path, with a 10% chance of freezing them for 10.0 seconds"
            },
            {
              "name": "Laser Beam",
              "ingredients": ["Laser", "Light"],
              "category": "Laser",
              "description": "Emit a laser beam on hit that deals 30-42 damage and blinds enemies for 8 seconds"
            },
            {
              "name": "Radiation Beam",
              "ingredients": ["Laser", "Cell"],
              "category": "Laser",
              "description": "Emit a radiation beam on hit that deals 24-48 damage and applies 1 stack of radiation (max 5 stacks). Radiation lasts for 15 seconds and cause enemies to receive 10% more damage from all sources per stack"
            },
            {
              "name": "Sun",
              "ingredients": ["Light", "Burn"],
              "category": "Light",
              "description": "Blind all enemies in view and add 1 stacks of burn every second (max 5 stacks). Burn lasts for 6 seconds and deals 6-12 damage per stack per second"
            },
            {
              "name": "Laser Beam",
              "ingredients": ["Light", "Laser"],
              "category": "Light",
              "description": "Emit a laser beam on hit that deals 30-42 damage and blinds enemies for 8 seconds"
            },
            {
              "name": "Flash",
              "ingredients": ["Light", "Lightning"],
              "category": "Light",
              "description": "Damage all enemies on screen for 1-3 damage after hitting an enemy and blind them for 2 seconds"
            },
            {
              "name": "Flicker",
              "ingredients": ["Light", "Dark"],
              "category": "Light",
              "description": "Deals 1-7 damage to every enemy on screen every 1.4 seconds"
            },
            {
              "name": "Lovestruck",
              "ingredients": ["Light", "Charm"],
              "category": "Light",
              "description": "Inflict lovestruck on hit to enemies for 20 seconds. Lovestruck units have a 50% chance of healing you for 5 health when they attack"
            },
            {
              "name": "Lightning Rod",
              "ingredients": ["Lightning", "Iron"],
              "category": "Lightning",
              "description": "Plants a lightning rod into enemies it hits. These enemies are struck by lightning every 3.0 seconds, dealing 1-30 damage to up to 8 nearby enemies"
            },
            {
              "name": "Blizzard",
              "ingredients": ["Lightning", "Freeze"],
              "category": "Lightning",
              "description": "Freezes all enemies within a 2 tile radius for 0.8 seconds, dealing 1-50 damage"
            },
            {
              "name": "Flash",
              "ingredients": ["Lightning", "Light"],
              "category": "Lightning",
              "description": "Damage all enemies on screen for 1-3 damage after hitting an enemy and blind them for 2 seconds"
            },
            {
              "name": "Storm",
              "ingredients": ["Lightning", "Wind"],
              "category": "Lightning",
              "description": "Emits lightning to strike nearby enemies every second, dealing 1-40 damage"
            },
            {
              "name": "Lovestruck",
              "ingredients": ["Lightning", "Charm"],
              "category": "Lightning",
              "description": "Inflicts lovestruck on hit enemies for 20 seconds. Lovestruck units have a 50% chance of healing you for 5 health when they attack"
            },
            {
              "name": "Swamp",
              "ingredients": ["Poison", "Earthquake"],
              "category": "Poison",
              "description": "Leaves behind tar blobs over time. Enemies who walk into tar blobs are dealt 15-30, are slowed by 50% for 7 seconds and gain 1 stack of poison (max 8 stacks). Each stack of poison deals 1-3 damage per second. This ball and its tar blobs also deal 6-12 damage to nearby units"
            },
            {
              "name": "Nuclear Bomb",
              "ingredients": ["Poison", "Bomb"],
              "category": "Poison",
              "description": "Explodes when hitting an enemy, dealing 300-500 damage to nearby enemies and applying 1 stack of radiation to everyone present indefinitely (max 5 stacks). Each stack of radiation increases damage received by 10%. Has a 3-second cooldown"
            },
            {
              "name": "Virus",
              "ingredients": ["Poison", "Ghost"],
              "category": "Poison",
              "description": "Applies 1 stack of disease to units it hits (max 8 stacks). Disease lasts for 6 seconds. Each stack of disease deals 3-6 damage per second and diseased units have a 15% chance of passing a stack to undiseased nearby enemies each second"
            },
            {
              "name": "Radiation Beam",
              "ingredients": ["Poison", "Laser"],
              "category": "Poison",
              "description": "Emit a radiation beam on hit that deals 24-48 damage and applies 1 stack of radiation (max 5 stacks). Radiation lasts for 15 seconds and cause enemies to receive 10% more damage from all sources per stack"
            },
            {
              "name": "Noxious",
              "ingredients": ["Poison", "Wind"],
              "category": "Poison",
              "description": "Passes through enemies and applies 3 stacks of poison to nearby enemies within a 2 tile radius. Poison lasts for 4 seconds and each stack deals 1-3 damage per second"
            },
            {
              "name": "Vampire Lord",
              "ingredients": ["Vampire", "Bleed"],
              "category": "Vampire",
              "description": "Each hit inflicts 3 stacks of bleed. Heals 1 health and consumes all stacks when hitting an enemy with at least 10 stacks of bleed"
            },
            {
              "name": "Mosquito Swarm",
              "ingredients": ["Vampire", "Egg Sac"],
              "category": "Vampire",
              "description": "Explode into 3-6 mosquitoes. Mosquitos attack random enemies, dealing 80-120 damage each. If a mosquito kills an enemy, they steal 1 health"
            },
            {
              "name": "Mosquito King",
              "ingredients": ["Vampire", "Brood Mother"],
              "category": "Vampire",
              "description": "Spawns a mosquito each time it hits an enemy. Mosquitos attack a random enemy, dealing 80-120 damage each. If a mosquito kills an enemy, they steal 1 health"
            },
            {
              "name": "Succubus",
              "ingredients": ["Vampire", "Charm"],
              "category": "Vampire",
              "description": "Each hit has a 4% chance of charming the enemy for 9 seconds. Heals 1 when hitting a charmed enemy"
            },
            {
              "name": "Soul Sucker",
              "ingredients": ["Vampire", "Ghost"],
              "category": "Vampire",
              "description": "Passes through enemies and saps them, with a 30% chance of stealing 1 health and reducing their attack, damage by 20%. Lifesteal chance only applies once per enemy"
            },
            {
              "name": "Blizzard",
              "ingredients": ["Wind", "Freeze"],
              "category": "Wind",
              "description": "Freezes all enemies within a 2 tile radius for 0.8 seconds, dealing 1-50 damage"
            },
            {
              "name": "Inferno",
              "ingredients": ["Wind", "Burn"],
              "category": "Wind",
              "description": "Applies 1 stack of burn every second to all enemies within a 2 tile radius. Burn lasts for 6 seconds, dealing 3-7 damage per stack per second"
            },
            {
              "name": "Storm",
              "ingredients": ["Wind", "Lightning"],
              "category": "Lightning",
              "description": "Emits lightning to strike nearby enemies every second, dealing 1-40 damage"
            },
            {
              "name": "Noxious",
              "ingredients": ["Wind", "Poison"],
              "category": "Wind",
              "description": "Passes through enemies and applies 3 stacks of poison to nearby enemies within a 2 tile radius. Poison lasts for 4 seconds and each stack deals 1-3 damage per second"
            },
            {
              "name": "Sandstorm",
              "ingredients": ["Wind", "Earthquake"],
              "category": "Wind",
              "description": "Goes through enemies and is surrounded by a raging storm dealing 10-20 damage per second and blinding nearby enemies for 3 seconds"
            },
            {
              "name": "Satan",
              "ingredients": ["Succubus", "Incubus"],
              "category": "Special",
              "description": "While active, add 1 stack of burn to all active enemies per second (max 5 stacks), dealing 10-20 damage per stack per second and make them go berserk, dealing 15-24 damage to adjacent enemies every second"
            },
            {
              "name": "Nosferatu",
              "ingredients": ["Vampire Lord", "Spider Queen", "Mosquito King"],
              "category": "Special",
              "description": "Spawns a vampire bat each bounce. Vampire bats fly towards a random enemy, dealing 132-176 damage on hit, turning into a Vampire Lord"
            }
          ]
        };

        // Embedded passives data (moved from passives.json)
        const passivesData = {
  "basePassives": [
    {
      "name": "Archer's Effigy",
      "description": "Every 7-12 rows, spawn a stone archer with 160 health on your side. Stone archers are immune to ball damage and shoot arrows at enemies, dealing 10-20 each",
      "requirement": "N/A"
    },
    {
      "name": "Artificial Heart",
      "description": "Friendly pieces gain 100% more health",
      "requirement": "The player needs to have at least one other passive that gives them 'friendly pieces' (e.g. Archer's Effigy)"
    },
    {
      "name": "Baby Rattle",
      "description": "Gain 1.5x baby balls, but your aim becomes scattered",
      "requirement": "N/A"
    },
    {
      "name": "Bandage Roll",
      "description": "Shoot 1-2 baby balls each time you're healed",
      "requirement": "N/A"
    },
    {
      "name": "Bottled Tornado",
      "description": "When you catch a special ball, automatically shoot 1-3 new baby balls in random directions",
      "requirement": "N/A"
    },
    {
      "name": "Breastplate",
      "description": "Decrease damage taken by 10%",
      "requirement": "N/A"
    },
    {
      "name": "Crown of Thorns",
      "description": "Destroy the 2 nearest enemies when you are hit from close range",
      "requirement": "N/A"
    },
    {
      "name": "Cursed Elixir",
      "description": "When a poisoned enemy dies, 10% chance for them to come back as a zombie with 240 health that moves up the board and fights enemies",
      "requirement": "The player needs to have a ball that applies Poison"
    },
    {
      "name": "Deadeye's Amulet",
      "description": "Critical hits deal 10-15 bonus damage",
      "requirement": "N/A"
    },
    {
      "name": "Diamond Hilted Dagger",
      "description": "Increase crit chance to 20% when hitting enemies in the front",
      "requirement": "N/A"
    },
    {
      "name": "Dynamite",
      "description": "Every 5-10 rows, spawn an enemy with dynamite attached to them. Destroying them will deal 200-500 damage to nearby enemies",
      "requirement": "N/A"
    },
    {
      "name": "Emerald Hilted Dagger",
      "description": "Increase crit chance to 20% when hitting enemies on their right side",
      "requirement": "N/A"
    },
    {
      "name": "Ethereal Cloak",
      "description": "Balls go through enemies and deal 25% bonus damage until they hit the back of the field",
      "requirement": "N/A"
    },
    {
      "name": "Everflowing Goblet",
      "description": "You can heal past your max health at 20% efficiency",
      "requirement": "N/A"
    },
    {
      "name": "Eye of the Beholder",
      "description": "10% chance to dodge incoming attacks",
      "requirement": "N/A"
    },
    {
      "name": "Fleet Feet",
      "description": "Increase movement speed by 10% and move at full speed while shooting",
      "requirement": "N/A"
    },
    {
      "name": "Frozen Spike",
      "description": "When an enemy is frozen, they emit a chill to nearby enemies that deals 10-20 damage",
      "requirement": "The player needs to have a ball that applies Freeze"
    },
    {
      "name": "Gemspring",
      "description": "Every 7-11 rows, spawn a Gemspring. Dealing damage to them causes them to drop an increasing amount of XP gems",
      "requirement": "N/A"
    },
    {
      "name": "Ghostly Corset",
      "description": "Balls go through enemies and deal 20% bonus damage when hitting them from the side",
      "requirement": "N/A"
    },
    {
      "name": "Ghostly Shield",
      "description": "Balls go through allies and heal them for 2 health",
      "requirement": "The player needs to have at least one other passive that gives them 'allies' (e.g. Archer's Effigy)"
    },
    {
      "name": "Golden Bull",
      "description": "Every 7-11 rows, spawn a golden bull with 400 health on your side. Golden bulls accrue 10 gold per minute. They also move up the field, blocking and attacking enemies in the way",
      "requirement": "N/A"
    },
    {
      "name": "Hand Fan",
      "description": "Slow down enemies in the same column as you by 50%",
      "requirement": "N/A"
    },
    {
      "name": "Hand Mirror",
      "description": "Projectiles have a 50% chance to reflect upon hitting you, dealing 20-40 damage if they hit an enemy",
      "requirement": "N/A"
    },
    {
      "name": "Healer's Effigy",
      "description": "Every 7-12 rows, spawn a stone healer with 100 health on your side, which heals you 10 health per minute while it's on the field. Healers are immune to ball damage and move up the field, blocking and attacking enemies in the way",
      "requirement": "N/A"
    },
    {
      "name": "Hourglass",
      "description": "Balls deal 150% damage, but damage decays by 30% each time they bounce (minimum 50%)",
      "requirement": "N/A"
    },
    {
      "name": "Kiss of Death",
      "description": "Charmed enemies have a 10% chance of dying after recovering",
      "requirement": "The player needs to have a ball that applies Charm"
    },
    {
      "name": "Lover's Quiver",
      "description": "Projectiles have a 40% chance to heal you for 1 health instead of hurting you",
      "requirement": "N/A"
    },
    {
      "name": "Magic Staff",
      "description": "Increase area-of-effect damage (such as earthquake, laser, and lightning) by 20%",
      "requirement": "N/A"
    },
    {
      "name": "Magnet",
      "description": "Increase range at which you pick up items and catch balls by 1.0 tiles",
      "requirement": "N/A"
    },
    {
      "name": "Midnight Oil",
      "description": "Balls that hit flaming enemies light on fire and deal 10-20 bonus fire damage on the next hit",
      "requirement": "The player needs to have a ball that applies Burn"
    },
    {
      "name": "Pressure Valve",
      "description": "Enemies explode on death, dealing 20-30 damage to adjacent enemies",
      "requirement": "N/A"
    },
    {
      "name": "Protective Charm",
      "description": "Gain a shield that blocks the next damage you would receive. Recharges after 60 seconds",
      "requirement": "N/A"
    },
    {
      "name": "Radiant Feather",
      "description": "Increases ball launch speed by 20%, but get knocked back a little each time you shoot a ball",
      "requirement": "N/A"
    },
    {
      "name": "Reacher's Spear",
      "description": "Increase crit chance to 20% when hitting enemies in the same column as you",
      "requirement": "N/A"
    },
    {
      "name": "Rubber Headband",
      "description": "Balls start off at 70% speed but increase by 20% each bounce (max 200%)",
      "requirement": "N/A"
    },
    {
      "name": "Ruby Hilted Dagger",
      "description": "Increase crit chance to 15% when hitting enemies in the back",
      "requirement": "N/A"
    },
    {
      "name": "Sapphire Hilted Dagger",
      "description": "Increase crit chance to 30% when hitting enemies on their left side",
      "requirement": "N/A"
    },
    {
      "name": "Shortbow",
      "description": "Increase fire rate by 15%",
      "requirement": "N/A"
    },
    {
      "name": "Silver Blindfold",
      "description": "Increase crit chance to 20% when hitting blinded enemies",
      "requirement": "N/A"
    },
    {
      "name": "Silver Bullet",
      "description": "Balls deal 20% bonus damage until they hit a wall",
      "requirement": "N/A"
    },
    {
      "name": "Slingshot",
      "description": "25% chance to launch a baby ball when you pick up a gem",
      "requirement": "N/A"
    },
    {
      "name": "Spiked Collar",
      "description": "Deal 30-50 to enemies the first time you get into their melee attack range",
      "requirement": "N/A"
    },
    {
      "name": "Stone Effigy",
      "description": "Every 7-12 rows, spawn a stone soldier with 200 health on your side. Stone soldiers are immune to ball damage and move up the field, blocking and attacking enemies in the way",
      "requirement": "N/A"
    },
    {
      "name": "Traitor's Cowl",
      "description": "Stone allies can now be damaged by your balls, but you heal 2 health when a ball hits one",
      "requirement": "The player needs to have at least one other passive that gives them 'stone allies' (e.g. Archer's Effigy)"
    },
    {
      "name": "Turret",
      "description": "Floats around your character and shoots a baby ball at enemies every 2.0 seconds",
      "requirement": "N/A"
    },
    {
      "name": "Upturned Hatchet",
      "description": "Balls deal 80% more damage after hitting the back of the field, otherwise damage is reduced by 20%",
      "requirement": "N/A"
    },
    {
      "name": "Vampiric Sword",
      "description": "Each kill heals you by 5, but each shot you take deals 2 damage to you",
      "requirement": "N/A"
    },
    {
      "name": "Voodoo Doll",
      "description": "Curse has a 10% chance of killing enemies",
      "requirement": "The player needs to have a ball that applies Curse"
    },
    {
      "name": "Wagon Wheel",
      "description": "Each time a ball hits a wall, it deals 30% extra damage on the next hit",
      "requirement": "N/A"
    },
    {
      "name": "War Horn",
      "description": "All baby balls deal 20% more damage",
      "requirement": "N/A"
    },
    {
      "name": "Wretched Onion",
      "description": "Deal 6-12 per second to enemies within 2 tiles",
      "requirement": "N/A"
    }
  ],
  "evolvedPassives": [
    {
      "name": "Cornucopia",
      "ingredients": ["Baby Rattle", "War Horn"],
      "description": "Each time baby balls are created, spawn 0-1 additional baby balls"
    },
    {
      "name": "Gracious Impaler",
      "ingredients": ["Reacher's Spear", "Deadeye's Amulet"],
      "description": "Critical hits have a 5% chance to instantly kill enemies"
    },
    {
      "name": "Odiferous Shell",
      "ingredients": ["Wretched Onion", "Breastplate"],
      "description": "When you touch enemies, they have a 50% chance of instantly dying"
    },
    {
      "name": "Phantom Regalia",
      "ingredients": ["Ghostly Corset", "Ethereal Cloak"],
      "description": "Balls go through enemies until they hit the back wall. Balls deal 50% more damage when going through enemies"
    },
    {
      "name": "Soul Reaver",
      "ingredients": ["Vampiric Sword", "Everflowing Goblet"],
      "description": "Each kill heals you by 1 and you can heal past your max health at 30% efficiency"
    },
    {
      "name": "Tormenters Mask",
      "ingredients": ["Spiked Collar", "Crown of Thorns"],
      "description": "Enemies have a 10% chance of dying immediately the first time they detect you"
    },
    {
      "name": "Wings of the Anointed",
      "ingredients": ["Fleet Feet", "Radiant Feather"],
      "description": "Balls move 40% faster and you move 20% faster. You no longer are affected by environmental hazards on the ground"
    },
    {
      "name": "Deadeye's Cross",
      "ingredients": ["Diamond Hilted Dagger", "Emerald Hilted Dagger", "Ruby Hilted Dagger", "Sapphire Hilted Dagger"],
      "description": "Increase critical hit chance to 60%"
    }
  ]
};

        function PassivesGraph() {
          const [active, setActive] = useState(null);

          const base = passivesData.basePassives || [];
          const evolved = passivesData.evolvedPassives || [];

          // Split base passives into 3 columns
          const cols = [[], [], []];
          base.forEach((p, i) => cols[i % 3].push(p));

          return (
            <div className="p-4">
              <div className="grid grid-cols-4 gap-4">
                {cols.map((col, ci) => (
                  <div key={`col-${ci}`} className="space-y-3">
                    {col.map((p) => (
                      <div
                        key={p.name}
                        onMouseEnter={() => setActive(p)}
                        onMouseLeave={() => setActive(null)}
                        onClick={() => setActive(active && active.name === p.name ? null : p)}
                        className="p-3 bg-slate-800 rounded-md border border-slate-700 hover:border-slate-500 cursor-pointer"
                      >
                        <div className="font-semibold text-white">{p.name}</div>
                        <div className="text-slate-300 text-sm truncate">{p.description}</div>
                      </div>
                    ))}
                  </div>
                ))}

                {/* evolved passives column */}
                <div className="space-y-3">
                  <div className="text-white font-bold mb-2">Evolved Passives</div>
                  {evolved.map((e) => (
                    <div
                      key={e.name}
                      onMouseEnter={() => setActive(e)}
                      onMouseLeave={() => setActive(null)}
                      onClick={() => setActive(active && active.name === e.name ? null : e)}
                      className="p-3 bg-amber-900/10 rounded-md border border-amber-700 hover:border-amber-500 cursor-pointer"
                    >
                      <div className="font-semibold text-amber-200">{e.name}</div>
                      <div className="text-slate-300 text-sm truncate">{e.description}</div>
                      {e.ingredients && (
                        <div className="text-slate-400 text-xs mt-1">Ingredients: {e.ingredients.join(', ')}</div>
                      )}
                    </div>
                  ))}
                </div>
              </div>

              <div className="mt-4 bg-slate-900/80 p-3 rounded-md">
                {active ? (
                  <div>
                    <div className="text-lg font-bold text-white">{active.name}</div>
                    <div className="text-slate-300 mt-1">{active.description}</div>
                    {active.requirement && <div className="text-slate-400 text-sm mt-2">Requirement: {active.requirement}</div>}
                  </div>
                ) : (
                  <div className="text-slate-400">Hover or click a passive to see details.</div>
                )}
              </div>
            </div>
          );
        }

        function BallEvolutionGraph() {
          const [selectedBall, setSelectedBall] = useState(null);
          const [hoveredNode, setHoveredNode] = useState(null);
          const [tab, setTab] = useState('Evolutions');

          const { evolutions, baseElements, nameMap, uniqueEvos, recipesByEvo, altNodes } = useMemo(() => {
            const data = jsonData;
            const newNameMap = {};
            const allNames = new Set();
            data.evolutions.forEach(e => {
                allNames.add(e.name);
                e.ingredients.forEach(i => allNames.add(i));
            });
            allNames.forEach(name => newNameMap[name.toUpperCase().replace(/\s/g, ' ')] = name);

            const evos = data.evolutions.map(e => ({
                ...e,
                name: e.name.toUpperCase().replace(/\s/g, ' '),
                ingredients: e.ingredients.map(i => i.toUpperCase().replace(/\s/g, ' '))
            }));

            const evoNames = new Set(evos.map(e => e.name));
            const allIngredients = new Set(evos.flatMap(e => e.ingredients));
            const base = [...allIngredients].filter(ing => !evoNames.has(ing));

            const uniqueEvos = [];
            const seenUnique = new Set();
            evos.forEach(evo => {
              if (!seenUnique.has(evo.name)) {
                seenUnique.add(evo.name);
                uniqueEvos.push(evo);
              }
            });
            
            const recipesByEvo = {};
            // Normalize and deduplicate recipes so mirrored combinations (A+B and B+A)
            // are only shown once per evolution.
            evos.forEach(evo => {
              const name = evo.name;
              const ingredients = evo.ingredients;
              if (!recipesByEvo[name]) recipesByEvo[name] = [];
              const normalized = ingredients.slice().sort().join('||');
              const already = recipesByEvo[name].some(r => r.slice().sort().join('||') === normalized);
              if (!already) recipesByEvo[name].push(ingredients);
            });

            // Collect nodes that participate in alternative (non-primary) recipes
            // so we can style their borders in gold for easier parsing.
            const altNodes = new Set();
            Object.entries(recipesByEvo).forEach(([evoName, recs]) => {
              recs.forEach((rec, idx) => {
                if (idx > 0) {
                  altNodes.add(evoName);
                  rec.forEach(i => altNodes.add(i));
                }
              });
            });

            return { evolutions: evos, baseElements: base.sort(), nameMap: newNameMap, uniqueEvos, recipesByEvo, altNodes };
          }, []);

          const getColor = (element) => {
            const colors = {
              'BLEED': '#dc2626', 'BROOD MOTHER': '#9333ea', 'BURN': '#ea580c', 'CELL': '#16a34a', 'CHARM': '#db2777',
              'DARK': '#1f2937', 'EARTHQUAKE': '#b45309', 'EGG SAC': '#65a30d', 'FREEZE': '#0891b2', 'GHOST': '#475569',
              'IRON': '#64748b', 'LASER': '#eab308', 'LASER (HORIZONTAL)': '#eab308', 'LASER (VERTICAL)': '#eab308',
              'LIGHT': '#facc15', 'LIGHTNING': '#4f46e5', 'POISON': '#059669', 'VAMPIRE': '#be185d', 'WIND': '#0369a1',
            };
            if (evolutions) {
                const evoColorSource = evolutions.find(e => e.name === element);
                if (evoColorSource) return colors[evoColorSource.ingredients[0]] || '#6b7280';
            }
            return colors[element] || '#6b7280';
          };

          const getIconSlug = (name) => {
            if (!name) return '';
            return name.toLowerCase().replace(/ /g, '-').replace(/[^a-z0-9-]/g, '');
          };

          const getIconUrls = (name) => {
            const slug = getIconSlug(name);
            if (!slug) return [];
            return [`icons/${slug}.png`];
          };

          const baseWidth = 140;
          const baseHeight = 45;
          const rowSpacing = 80;
          const evoSpacing = 60;

          const { positions, svgWidth, svgHeight, levels, columnAreas, columnHeaders } = useMemo(() => {
            if (!uniqueEvos || !baseElements) return { positions: {}, svgWidth: 1400, svgHeight: 900, levels: {}, columnAreas: {}, columnHeaders: [] };
            
            const levels = {};
            let maxLevel = 0;
            baseElements.forEach(b => levels[b] = 0);

            let changed = true;
            while (changed) {
              changed = false;
              uniqueEvos.forEach(evo => {
                if (levels[evo.name] !== undefined) return;
                const ingredientLevels = evo.ingredients.map(ing => levels[ing]);
                if (ingredientLevels.some(l => l === undefined)) return;
                const maxIngredientLevel = Math.max(...ingredientLevels);
                levels[evo.name] = maxIngredientLevel + 1;
                if (levels[evo.name] > maxLevel) maxLevel = levels[evo.name];
                changed = true;
              });
            }
            
            uniqueEvos.forEach(evo => {
                if (levels[evo.name] === undefined) {
                    levels[evo.name] = maxLevel + 1;
                }
            });

            const positions = {};
            const columnWidth = baseWidth + 100;
            
            baseElements.forEach((element, idx) => {
              positions[element] = { x: 40, y: 50 + idx * rowSpacing };
            });

            let totalHeight = 50 + baseElements.length * rowSpacing;

            const numSubColumns = 2;
            const subColumnWidth = baseWidth + 80;
            const level1StartX = 40 + columnWidth;
            const subColumnYOffsets = new Array(numSubColumns).fill(50);

            if (maxLevel >= 1) {
                const level1Nodes = uniqueEvos.filter(evo => levels[evo.name] === 1);
                const level1Groups = {};
                level1Nodes.forEach(node => {
                    const category = uniqueEvos.find(e => e.name === node.name)?.category.toUpperCase() || '';
                    if (!level1Groups[category]) {
                        level1Groups[category] = [];
                    }
                    level1Groups[category].push(node);
                });

                baseElements.forEach((baseElement, index) => {
                    const group = level1Groups[baseElement];
                    if (!group || group.length === 0) return;

                    const subColIndex = index % numSubColumns;
                    const groupX = level1StartX + subColIndex * subColumnWidth;

                    const baseElementY = positions[baseElement].y;
                    let groupY = Math.max(baseElementY, subColumnYOffsets[subColIndex]);
                    
                    group.forEach((node, nodeIndex) => {
                        const y = groupY + nodeIndex * evoSpacing;
                        positions[node.name] = { x: groupX, y: y };
                    });
                    
                    subColumnYOffsets[subColIndex] = groupY + group.length * evoSpacing + rowSpacing / 2;
                });

                totalHeight = Math.max(totalHeight, ...subColumnYOffsets);
            }

            const level2PlusStartX = level1StartX + (maxLevel > 0 ? numSubColumns * subColumnWidth : 0);
            for (let level = 2; level <= maxLevel + 1; level++) {
              const nodesInLevel = Object.keys(levels).filter(name => levels[name] === level);
              const nodesWithTargetY = nodesInLevel.map(name => {
                const evo = uniqueEvos.find(e => e.name === name) || { ingredients: [] };
                const ingredientPositions = evo.ingredients.map(ing => positions[ing]).filter(p => p);
                let targetY = 0;
                if (ingredientPositions.length > 0) {
                  targetY = ingredientPositions.reduce((sum, p) => sum + p.y, 0) / ingredientPositions.length;
                }
                return { name, targetY };
              });

              nodesWithTargetY.sort((a, b) => a.targetY - b.targetY);

              let lastYInColumn = 0;
              nodesWithTargetY.forEach(({ name, targetY }) => {
                const x = level2PlusStartX + (level - 2) * columnWidth;
                const y = Math.max(targetY, lastYInColumn + evoSpacing);
                positions[name] = { x, y };
                lastYInColumn = y;
              });
              if (lastYInColumn > totalHeight) totalHeight = lastYInColumn;
            }

            const newSvgWidth = level2PlusStartX + (maxLevel > 1 ? (maxLevel - 1) * columnWidth : 0) + baseWidth + 40;
            
            const columnAreas = {
                base: { x: 0, width: columnWidth + 20 },
                evolved: { x: columnWidth + 20, width: numSubColumns * subColumnWidth },
                ultimate: { x: columnWidth + 20 + numSubColumns * subColumnWidth, width: newSvgWidth - (columnWidth + 20 + numSubColumns * subColumnWidth) }
            };
            
            const columnHeaders = [
                { text: 'Base Balls', x: columnAreas.base.x + columnAreas.base.width / 2, y: 30, id: 'base' },
                { text: 'Evolved Balls', x: columnAreas.evolved.x + columnAreas.evolved.width / 2, y: 30, id: 'evolved' },
                { text: 'Ultimate Balls', x: columnAreas.ultimate.x + columnAreas.ultimate.width / 2, y: 30, id: 'ultimate' }
            ];

            return { positions, svgWidth: newSvgWidth, svgHeight: totalHeight + baseHeight, levels, columnAreas, columnHeaders };
          }, [uniqueEvos, baseElements]);

          const getAncestors = (ballName, allEvolutions) => {
            const ancestors = new Set();
            const toProcess = [ballName];
            const processed = new Set();

            while(toProcess.length > 0) {
                const currentBall = toProcess.pop();
                if (processed.has(currentBall)) continue;
                processed.add(currentBall);

                const recipes = allEvolutions.filter(e => e.name === currentBall);
                recipes.forEach(recipe => {
                    recipe.ingredients.forEach(ing => {
                        ancestors.add(ing);
                        toProcess.push(ing);
                    });
                });
            }
            return ancestors;
        };

        const getDescendants = (ballName, allEvolutions) => {
            const descendants = new Set();
            const toProcess = [ballName];
            const processed = new Set();

            while(toProcess.length > 0) {
                const currentBall = toProcess.pop();
                if (processed.has(currentBall)) continue;
                processed.add(currentBall);

                const children = allEvolutions.filter(e => e.ingredients.includes(currentBall));
                children.forEach(child => {
                    descendants.add(child.name);
                    toProcess.push(child.name);
                });
            }
            return descendants;
        };

        const highlightedChain = useMemo(() => {
            if (!selectedBall || !evolutions) return new Set();
            const ancestors = getAncestors(selectedBall, evolutions);
            const descendants = getDescendants(selectedBall, evolutions);
            const chain = new Set([...ancestors, ...descendants, selectedBall]);
            return chain;
        }, [selectedBall, evolutions]);

          const NodeContent = ({ name, pos, nameMap }) => {
            const displayName = nameMap[name] || name;
            const urls = getIconUrls(displayName);
            const imgSize = 36;
            const padding = 5;
            const imgX = pos.x + padding;
            const imgY = pos.y + (baseHeight - imgSize) / 2;
            const primary = urls[0];
            
            const textX = pos.x + padding + imgSize + padding;
            const textY = pos.y + baseHeight / 2;

            const wrapText = (text) => {
                const maxCharsPerLine = 15;
                if (text.length <= maxCharsPerLine) return [text];
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                for(const word of words) {
                    if ((currentLine + ' ' + word).trim().length > maxCharsPerLine && currentLine.length > 0) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = (currentLine + ' ' + word).trim();
                    }
                }
                if (currentLine) lines.push(currentLine);
                return lines;
            };
            const lines = wrapText(displayName);

            return (
                <g>
                    {primary && (
                        <image
                            href={primary} x={imgX} y={imgY} width={imgSize} height={imgSize}
                            preserveAspectRatio="xMidYMid slice"
                            onError={(e) => { e.target.style.display = 'none'; }}
                            className="pointer-events-none select-none"
                        />
                    )}
                    <text
                        x={textX}
                        y={textY - (lines.length > 1 ? (lines.length - 1) * 6 : 0)}
                        textAnchor="start"
                        dominantBaseline="middle"
                        fontSize={displayName.length > 15 ? "10" : "11"}
                        fontWeight="bold"
                        fill="white"
                        className="pointer-events-none select-none"
                    >
                        {lines.map((line, i) => (
                            <tspan key={i} x={textX} dy={i === 0 ? 0 : '1.2em'}>{line}</tspan>
                        ))}
                    </text>
                </g>
            );
        };

          const [searchTerm, setSearchTerm] = useState('');

          const allNodeNames = useMemo(() => {
            if (!baseElements || !evolutions) return [];
            const evoNames = new Set(evolutions.map(e => e.name));
            const allNames = new Set([...baseElements, ...evoNames]);
            return Array.from(allNames).sort();
          }, [evolutions, baseElements]);

          const searchResults = useMemo(() => {
            if (!searchTerm || !allNodeNames) return [];
            return allNodeNames
              .filter(name => (nameMap[name] || name).toLowerCase().includes(searchTerm.toLowerCase()))
              .slice(0, 10);
          }, [searchTerm, allNodeNames, nameMap]);


          const activeNode = selectedBall || hoveredNode;
          const recipesForActiveNode = useMemo(() => {
            if (!activeNode || !evolutions) return [];
            
            const recipeStrings = evolutions
              .filter(evo => evo.name === activeNode)
              .map(evo => {
                  const sortedIngredients = evo.ingredients
                      .map(ing => nameMap[ing] || ing)
                      .sort();
                  return sortedIngredients.join(' + ');
              });

            const uniqueRecipes = [...new Set(recipeStrings)];
            
            return uniqueRecipes;
          }, [activeNode, evolutions, nameMap]);

          const descriptionForActiveNode = useMemo(() => {
            if (!activeNode || !evolutions) return '';
            const evo = evolutions.find(e => e.name === activeNode);
            return evo ? evo.description : '';
          }, [activeNode, evolutions]);

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-950 p-6">
              <div className="max-w-full">
                <div className="flex items-center justify-between mb-4">
                  <h1 className="text-4xl font-bold text-white mb-0">Ball x Pit</h1>
                  <div className="inline-flex rounded-md bg-slate-800/40 p-1">
                    <button onClick={() => setTab('Evolutions')} className={`px-3 py-1 rounded ${tab === 'Evolutions' ? 'bg-slate-700 text-white' : 'text-slate-300'}`}>Evolutions</button>
                    <button onClick={() => setTab('Passives')} className={`ml-2 px-3 py-1 rounded ${tab === 'Passives' ? 'bg-slate-700 text-white' : 'text-slate-300'}`}>Passives</button>
                  </div>
                </div>

                <div className="relative mb-4 max-w-md" style={{ display: tab === 'Evolutions' ? 'block' : 'none' }}>
                  <input
                    type="text"
                    placeholder="Search for a ball..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full bg-slate-700 text-white placeholder-slate-400 rounded-md py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                  {searchResults.length > 0 && (
                    <div className="absolute z-10 w-full mt-1 bg-slate-800 border border-slate-700 rounded-md shadow-lg max-h-60 overflow-y-auto">
                      {searchResults.map(name => (
                        <div key={name} onClick={() => { setSelectedBall(name); setSearchTerm(''); }} className="px-4 py-2 text-white hover:bg-slate-700 cursor-pointer">
                          {nameMap[name] || name}
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                <div style={{ display: tab === 'Passives' ? 'block' : 'none' }}>
                  <PassivesGraph />
                </div>

                <div className="relative" style={{ display: tab === 'Evolutions' ? 'block' : 'none' }}>
                  <div className="bg-slate-800 rounded-lg overflow-y-auto overflow-x-auto" style={{ maxHeight: '84vh' }}>
                    <svg
                      width={svgWidth}
                      height={svgHeight}
                      viewBox={`0 0 ${svgWidth} ${svgHeight}`}
                      className="bg-slate-700"
                      style={{ minHeight: '900px', display: 'block' }}
                    >
                      <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                          <polygon points="0 0, 10 3, 0 6" fill="#94a3b8" />
                        </marker>
                        <marker id="arrowhead-gold" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                          <polygon points="0 0, 10 3, 0 6" fill="#f59e0b" />
                        </marker>
                        {/* Background Gradients */}
                        <linearGradient id="base-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style={{stopColor: 'rgba(156, 163, 175, 0.15)'}} />
                            <stop offset="100%" style={{stopColor: 'rgba(156, 163, 175, 0)'}} />
                        </linearGradient>
                        <linearGradient id="evolved-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style={{stopColor: 'rgba(59, 130, 246, 0.08)'}} />
                            <stop offset="100%" style={{stopColor: 'rgba(59, 130, 246, 0)'}} />
                        </linearGradient>
                        <linearGradient id="ultimate-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style={{stopColor: 'rgba(252, 211, 77, 0.1)'}} />
                            <stop offset="100%" style={{stopColor: 'rgba(252, 211, 77, 0)'}} />
                        </linearGradient>
                        {/* Text Gradients */}
                        <linearGradient id="base-text-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#e2e8f0" />
                            <stop offset="100%" stopColor="#94a3b8" />
                        </linearGradient>
                        <linearGradient id="evolved-text-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#93c5fd" />
                            <stop offset="100%" stopColor="#3b82f6" />
                        </linearGradient>
                        <linearGradient id="ultimate-text-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#fde047" />
                            <stop offset="100%" stopColor="#f59e0b" />
                        </linearGradient>
                      </defs>

                      {/* Backgrounds */}
                      {columnAreas.base && <rect x={columnAreas.base.x} y="0" width={columnAreas.base.width} height="100%" fill="url(#base-gradient)" />}
                      {columnAreas.evolved && <rect x={columnAreas.evolved.x} y="0" width={columnAreas.evolved.width} height="100%" fill="url(#evolved-gradient)" />}
                      {columnAreas.ultimate && <rect x={columnAreas.ultimate.x} y="0" width={columnAreas.ultimate.width} height="100%" fill="url(#ultimate-gradient)" />}

                      {/* Headers */}
                      {columnHeaders.map(header => (
                        <text
                            key={header.id}
                            x={header.x}
                            y={header.y}
                            textAnchor="middle"
                            fontSize="20"
                            fontWeight="bold"
                            fill={`url(#${header.id}-text-gradient)`}
                            style={{ textShadow: '1px 1px 2px rgba(0,0,0,0.5)' }}
                        >
                            {header.text}
                        </text>
                      ))}

                      {/* Lines */}
                      {Object.entries(recipesByEvo).map(([evoName, recipes]) => {
                        const endPos = positions[evoName];
                        if (!endPos) return null;
                        const numRecipes = recipes.length;

                        return recipes.map((recipe, recipeIndex) => {
                            const yOffset = (baseHeight / (numRecipes + 1)) * (recipeIndex + 1);
                            const lineStyle = recipeIndex === 0 ? "none" : recipeIndex === 1 ? "4 4" : "1 5";

                            return recipe.map((ing, ingIdx) => {
                                const startPos = positions[ing];
                                if (!startPos) return null;

                                const isHighlighted = highlightedChain.has(evoName) && highlightedChain.has(ing);
                                const isAlt = recipeIndex > 0;
                                // Keep alternative (non-primary) recipes gold even when highlighted;
                                // highlight should affect width/opacity but not change alt color.
                                const strokeColor = isAlt ? '#f59e0b' : (isHighlighted ? '#3b82f6' : '#64748b');
                                const markerId = isAlt ? 'arrowhead-gold' : 'arrowhead';

                                return (
                                  <line
                                    key={`line-${evoName}-${recipeIndex}-${ingIdx}`}
                                    x1={startPos.x + baseWidth}
                                    y1={startPos.y + baseHeight / 2}
                                    x2={endPos.x}
                                    y2={endPos.y + yOffset}
                                    stroke={strokeColor}
                                    strokeWidth={isHighlighted ? 2 : 1}
                                    strokeDasharray={lineStyle}
                                    markerEnd={`url(#${markerId})`}
                                    opacity={!selectedBall ? 0.4 : (isHighlighted ? 1 : 0.3)}
                                    className="transition-all"
                                  />
                                );
                            });
                        });
                      })}

                      {/* Nodes */}
                      {baseElements.map((element) => {
                        const pos = positions[element];
                        if (!pos) return null;
                        const isSelected = selectedBall === element;
                        const isInChain = highlightedChain.has(element);
                        const isAltNode = altNodes && altNodes.has && altNodes.has(element);

                        return (
                          <g key={`base-${element}`}>
                            <rect
                              x={pos.x} y={pos.y} width={baseWidth} height={baseHeight} rx="4"
                              fill={getColor(element)}
                              stroke={isSelected ? '#fff' : (isAltNode ? '#f59e0b' : (isInChain ? '#3b82f6' : 'none'))}
                              strokeWidth={isSelected ? 2 : (isAltNode ? 1.5 : (isInChain ? 1.5 : 0))}
                              opacity={!selectedBall || isInChain ? 1 : 0.3}
                              className="cursor-pointer transition-all hover:opacity-100"
                              onClick={() => setSelectedBall(selectedBall === element ? null : element)}
                              onMouseEnter={() => setHoveredNode(element)}
                              onMouseLeave={() => setHoveredNode(null)}
                            />
                            <NodeContent name={element} pos={pos} nameMap={nameMap} />
                          </g>
                        );
                      })}

                      {uniqueEvos.map((evo, idx) => {
                          const pos = positions[evo.name];
                          if (!pos) return null;
                          
                          const level = levels[evo.name];
                          const isUltimate = level >= 2;
                          const isSelected = selectedBall === evo.name;
                          const isInChain = highlightedChain.has(evo.name);
                          const isAltNode = altNodes && altNodes.has && altNodes.has(evo.name);

                          return (
                            <g key={`evo-${evo.name}-${idx}`}>
                              <rect
                                x={pos.x} y={pos.y} width={baseWidth} height={baseHeight} rx="4"
                                fill={getColor(evo.name)}
                                stroke={isSelected ? '#fff' : (isAltNode ? '#f59e0b' : (isUltimate ? 'gold' : (isInChain ? '#3b82f6' : 'none')))}
                                strokeWidth={isSelected ? 2 : (isAltNode ? 1.5 : (isUltimate ? 2.5 : (isInChain ? 1.5 : 0)))}
                                opacity={!selectedBall || isInChain ? 1 : 0.3}
                                className="cursor-pointer transition-all hover:opacity-100"
                                onClick={() => setSelectedBall(selectedBall === evo.name ? null : evo.name)}
                                onMouseEnter={() => setHoveredNode(evo.name)}
                                onMouseLeave={() => setHoveredNode(null)}
                              />
                              <NodeContent name={evo.name} pos={pos} nameMap={nameMap} />
                            </g>
                          );
                      })}
                    </svg>
                  </div>

                  {activeNode && (
                    <div className="absolute bottom-2 left-2 z-10 bg-slate-900/75 backdrop-blur-sm rounded-lg p-4 max-w-md">
                      <h3 className="text-white mb-2">
                          <span className="font-semibold">{(nameMap[activeNode] || activeNode)}</span>
                          {descriptionForActiveNode && <span className="font-normal">{`: ${descriptionForActiveNode}`}</span>}
                      </h3>
                      {recipesForActiveNode.length > 0 ? (
                        <div className="text-slate-300 text-sm">
                          {recipesForActiveNode.map((r, i) => (
                            <div key={i}>{r}</div>
                          ))}
                        </div>
                      ) : null}
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        }

        ReactDOM.render(<BallEvolutionGraph />, document.getElementById('root'));
    </script>
</body>
</html>