<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball x Pit Evolution Web</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef } = React;

        function BallEvolutionGraph() {
          const [selectedBall, setSelectedBall] = useState(null);
          const [hoveredNode, setHoveredNode] = useState(null);

          const evolutions = [
            { name: 'Leech', ingredients: ['BLEED', 'BROOD MOTHER'] },
            { name: 'Berserk', ingredients: ['BLEED', 'CHARM'] },
            { name: 'Berserk', ingredients: ['BURN', 'CHARM'] },
            { name: 'Sacrifice', ingredients: ['BLEED', 'DARK'] },
            { name: 'Hemorrhage', ingredients: ['BLEED', 'IRON'] },
            { name: 'Virus', ingredients: ['BLEED', 'POISON'] },
            { name: 'Vampire Lord', ingredients: ['BLEED', 'VAMPIRE'] },
            { name: 'Maggot', ingredients: ['BROOD MOTHER', 'CELL'] },
            { name: 'Spider Queen', ingredients: ['BROOD MOTHER', 'EGG SACK'] },
            { name: 'Mosquito King', ingredients: ['BROOD MOTHER', 'VAMPIRE'] },
            { name: 'Magma', ingredients: ['BURN', 'EARTHQUAKE'] },
            { name: 'Frozen Flame', ingredients: ['BURN', 'FREEZE'] },
            { name: 'Bomb', ingredients: ['BURN', 'IRON'] },
            { name: 'Sun', ingredients: ['BURN', 'LIGHT'] },
            { name: 'Inferno', ingredients: ['BURN', 'WIND'] },
            { name: 'Overgrowth', ingredients: ['CELL', 'EARTHQUAKE'] },
            { name: 'Voluptuous Egg sack', ingredients: ['CELL', 'EGG SACK'] },
            { name: 'Radiation Beam', ingredients: ['CELL', 'LASER'] },
            { name: 'Virus', ingredients: ['CELL', 'POISON'] },
            { name: 'Incubus', ingredients: ['CHARM', 'DARK'] },
            { name: 'Lovestruck', ingredients: ['CHARM', 'LIGHT'] },
            { name: 'Lovestruck', ingredients: ['CHARM', 'LIGHTNING'] },
            { name: 'Succubus', ingredients: ['CHARM', 'VAMPIRE'] },
            { name: 'Phantom', ingredients: ['DARK', 'GHOST'] },
            { name: 'Assassin', ingredients: ['DARK', 'IRON'] },
            { name: 'Flicker', ingredients: ['DARK', 'LIGHT'] },
            { name: 'Vampire Lord', ingredients: ['DARK', 'VAMPIRE'] },
            { name: 'Noxious', ingredients: ['DARK', 'WIND'] },
            { name: 'Black Hole', ingredients: ['DARK', 'SUN'] },
            { name: 'Glacier', ingredients: ['EARTHQUAKE', 'FREEZE'] },
            { name: 'Swamp', ingredients: ['EARTHQUAKE', 'POISON'] },
            { name: 'Sandstorm', ingredients: ['EARTHQUAKE', 'WIND'] },
            { name: 'Wraith', ingredients: ['FREEZE', 'GHOST'] },
            { name: 'Freeze Ray', ingredients: ['FREEZE', 'LASER'] },
            { name: 'Blizzard', ingredients: ['FREEZE', 'LIGHTNING'] },
            { name: 'Blizzard', ingredients: ['FREEZE', 'WIND'] },
            { name: 'Wraith', ingredients: ['GHOST', 'FREEZE'] },
            { name: 'Assassin', ingredients: ['GHOST', 'IRON'] },
            { name: 'Virus', ingredients: ['GHOST', 'POISON'] },
            { name: 'Soul Sucker', ingredients: ['GHOST', 'VAMPIRE'] },
            { name: 'Bomb', ingredients: ['IRON', 'BURN'] },
            { name: 'Shotgun', ingredients: ['IRON', 'EGG SACK'] },
            { name: 'Assassin', ingredients: ['IRON', 'GHOST'] },
            { name: 'Lightning Rod', ingredients: ['IRON', 'LIGHTNING'] },
            { name: 'Radiation Beam', ingredients: ['LASER', 'CELL'] },
            { name: 'Freeze Ray', ingredients: ['LASER', 'FREEZE'] },
            { name: 'Holy Laser', ingredients: ['LASER VERTICAL', 'LASER HORIZONTAL'] },
            { name: 'Laser Beam', ingredients: ['LASER', 'LIGHT'] },
            { name: 'Radiation Beam', ingredients: ['LASER', 'POISON'] },
            { name: 'Sun', ingredients: ['LIGHT', 'BURN'] },
            { name: 'Lovestruck', ingredients: ['LIGHT', 'CHARM'] },
            { name: 'Flicker', ingredients: ['LIGHT', 'DARK'] },
            { name: 'Laser Beam', ingredients: ['LIGHT', 'LASER'] },
            { name: 'Flash', ingredients: ['LIGHT', 'LIGHTNING'] },
            { name: 'Lovestruck', ingredients: ['LIGHTNING', 'CHARM'] },
            { name: 'Lightning Rod', ingredients: ['LIGHTNING', 'IRON'] },
            { name: 'Blizzard', ingredients: ['LIGHTNING', 'FREEZE'] },
            { name: 'Flash', ingredients: ['LIGHTNING', 'LIGHT'] },
            { name: 'Storm', ingredients: ['LIGHTNING', 'WIND'] },
            { name: 'Virus', ingredients: ['POISON', 'BLEED'] },
            { name: 'Virus', ingredients: ['POISON', 'CELL'] },
            { name: 'Swamp', ingredients: ['POISON', 'EARTHQUAKE'] },
            { name: 'Virus', ingredients: ['POISON', 'GHOST'] },
            { name: 'Radiation Beam', ingredients: ['POISON', 'LASER'] },
            { name: 'Noxious', ingredients: ['POISON', 'WIND'] },
            { name: 'Nuclear Bomb', ingredients: ['POISON', 'BOMB'] },
            { name: 'Vampire Lord', ingredients: ['VAMPIRE', 'BLEED'] },
            { name: 'Mosquito King', ingredients: ['VAMPIRE', 'BROOD MOTHER'] },
            { name: 'Succubus', ingredients: ['VAMPIRE', 'CHARM'] },
            { name: 'Vampire Lord', ingredients: ['VAMPIRE', 'DARK'] },
            { name: 'Mosquito Swarm', ingredients: ['VAMPIRE', 'EGG SACK'] },
            { name: 'Soul Sucker', ingredients: ['VAMPIRE', 'GHOST'] },
            { name: 'Inferno', ingredients: ['WIND', 'BURN'] },
            { name: 'Noxious', ingredients: ['WIND', 'DARK'] },
            { name: 'Sandstorm', ingredients: ['WIND', 'EARTHQUAKE'] },
            { name: 'Blizzard', ingredients: ['WIND', 'FREEZE'] },
            { name: 'Storm', ingredients: ['WIND', 'LIGHTNING'] },
            { name: 'Noxious', ingredients: ['WIND', 'POISON'] },
          ];

          const baseElements = ['BLEED', 'BROOD MOTHER', 'BURN', 'CELL', 'CHARM', 'DARK', 'EARTHQUAKE', 'EGG SACK', 'FREEZE', 'GHOST', 'IRON', 'LASER', 'LASER HORIZONTAL', 'LASER VERTICAL', 'LIGHT', 'LIGHTNING', 'POISON', 'VAMPIRE', 'WIND'];

          const getColor = (element) => {
            const colors = {
              'BLEED': '#dc2626', 'BROOD MOTHER': '#9333ea', 'BURN': '#ea580c', 'CELL': '#16a34a', 'CHARM': '#db2777',
              'DARK': '#1f2937', 'EARTHQUAKE': '#b45309', 'EGG SACK': '#65a30d', 'FREEZE': '#0891b2', 'GHOST': '#475569',
              'IRON': '#64748b', 'LASER': '#eab308', 'LASER HORIZONTAL': '#eab308', 'LASER VERTICAL': '#eab308',
              'LIGHT': '#facc15', 'LIGHTNING': '#4f46e5', 'POISON': '#059669', 'VAMPIRE': '#be185d', 'WIND': '#0369a1',
            };
            const evoColorSource = uniqueEvos.find(e => e.name === element);
            if (evoColorSource) return colors[evoColorSource.ingredients[0]] || '#6b7280';
            return colors[element] || '#6b7280';
          };

          const getIconSlug = (name) => {
            if (!name) return '';
            return name.toLowerCase().replace(/ /g, '-').replace(/[^a-z0-9-]/g, '');
          };

          const getIconUrls = (name) => {
            const slug = getIconSlug(name);
            if (!slug) return [];
            return [`icons/${slug}.png`];
          };

          const uniqueEvos = useMemo(() => {
            const seen = new Set();
            const result = [];
            evolutions.forEach(evo => {
              const key = evo.name;
              if (!seen.has(key)) {
                seen.add(key);
                result.push(evo);
              }
            });
            return result;
          }, []);

          const baseWidth = 140;
          const baseHeight = 45;
          const rowSpacing = 80;
          const evoSpacing = 60;

          const { positions, svgWidth, svgHeight } = useMemo(() => {
            const levels = {};
            let maxLevel = 0;
            baseElements.forEach(b => levels[b] = 0);

            let changed = true;
            while (changed) {
              changed = false;
              uniqueEvos.forEach(evo => {
                if (levels[evo.name] !== undefined) return;
                const ingredientLevels = evo.ingredients.map(ing => levels[ing]);
                if (ingredientLevels.some(l => l === undefined)) return;
                const maxIngredientLevel = Math.max(...ingredientLevels);
                levels[evo.name] = maxIngredientLevel + 1;
                if (levels[evo.name] > maxLevel) maxLevel = levels[evo.name];
                changed = true;
              });
            }
            
            uniqueEvos.forEach(evo => {
                if (levels[evo.name] === undefined) {
                    levels[evo.name] = maxLevel + 1;
                }
            });

            const positions = {};
            const columnWidth = baseWidth + 100;
            
            baseElements.forEach((element, idx) => {
              positions[element] = { x: 40, y: 50 + idx * rowSpacing };
            });

            let totalHeight = 50 + baseElements.length * rowSpacing;

            for (let level = 1; level <= maxLevel + 1; level++) {
              const nodesInLevel = Object.keys(levels).filter(name => levels[name] === level);
              const nodesWithTargetY = nodesInLevel.map(name => {
                const evo = uniqueEvos.find(e => e.name === name) || { ingredients: [] };
                const ingredientPositions = evo.ingredients.map(ing => positions[ing]).filter(p => p);
                let targetY = 0;
                if (ingredientPositions.length > 0) {
                  targetY = ingredientPositions.reduce((sum, p) => sum + p.y, 0) / ingredientPositions.length;
                }
                return { name, targetY };
              });

              nodesWithTargetY.sort((a, b) => a.targetY - b.targetY);

              let lastYInColumn = 0;
              nodesWithTargetY.forEach(({ name, targetY }) => {
                const x = 40 + level * columnWidth;
                const y = Math.max(targetY, lastYInColumn + evoSpacing);
                positions[name] = { x, y };
                lastYInColumn = y;
              });
              if (lastYInColumn > totalHeight) totalHeight = lastYInColumn;
            }

            const newSvgWidth = 40 + (maxLevel + 1) * columnWidth + baseWidth + 40;
            return { positions, svgWidth: newSvgWidth, svgHeight: totalHeight + baseHeight };
          }, [uniqueEvos, baseElements]);

          const NodeContent = ({ name, pos }) => {
            const urls = getIconUrls(name);
            const imgSize = 36;
            const padding = 5;
            const imgX = pos.x + padding;
            const imgY = pos.y + (baseHeight - imgSize) / 2;
            const primary = urls[0];
            
            const textX = pos.x + padding + imgSize + padding;
            const textY = pos.y + baseHeight / 2;

            const wrapText = (text) => {
                const maxCharsPerLine = 15;
                if (text.length <= maxCharsPerLine) return [text];
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                for(const word of words) {
                    if ((currentLine + ' ' + word).trim().length > maxCharsPerLine && currentLine.length > 0) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = (currentLine + ' ' + word).trim();
                    }
                }
                if (currentLine) lines.push(currentLine);
                return lines;
            };
            const lines = wrapText(name);

            return (
                <g>
                    {primary && (
                        <image
                            href={primary} x={imgX} y={imgY} width={imgSize} height={imgSize}
                            preserveAspectRatio="xMidYMid slice"
                            onError={(e) => { e.target.style.display = 'none'; }}
                            className="pointer-events-none select-none"
                        />
                    )}
                    <text
                        x={textX}
                        y={textY - (lines.length > 1 ? (lines.length - 1) * 6 : 0)}
                        textAnchor="start"
                        dominantBaseline="middle"
                        fontSize={name.length > 15 ? "10" : "11"}
                        fontWeight="bold"
                        fill="white"
                        className="pointer-events-none select-none"
                    >
                        {lines.map((line, i) => (
                            <tspan key={i} x={textX} dy={i === 0 ? 0 : '1.2em'}>{line}</tspan>
                        ))}
                    </text>
                </g>
            );
        };

          const [searchTerm, setSearchTerm] = useState('');

          const allNodeNames = useMemo(() => {
            const evoNames = new Set(evolutions.map(e => e.name));
            const allNames = new Set([...baseElements, ...evoNames]);
            return Array.from(allNames).sort();
          }, [evolutions, baseElements]);

          const searchResults = useMemo(() => {
            if (!searchTerm) return [];
            return allNodeNames
              .filter(name => name.toLowerCase().includes(searchTerm.toLowerCase()))
              .slice(0, 10);
          }, [searchTerm, allNodeNames]);


          const activeNode = selectedBall || hoveredNode;
          const recipesForActiveNode = useMemo(() => {
            if (!activeNode) return [];
            return evolutions
              .filter(evo => evo.name === activeNode)
              .map(evo => evo.ingredients.join(' + '));
          }, [activeNode, evolutions]);

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 to-slate-950 p-6">
              <div className="max-w-full">
                <h1 className="text-4xl font-bold text-white mb-2">Ball x Pit Evolution Web</h1>
                <div className="relative mb-4 max-w-md">
                  <input
                    type="text"
                    placeholder="Search for a ball..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full bg-slate-700 text-white placeholder-slate-400 rounded-md py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                  {searchResults.length > 0 && (
                    <div className="absolute z-10 w-full mt-1 bg-slate-800 border border-slate-700 rounded-md shadow-lg max-h-60 overflow-y-auto">
                      {searchResults.map(name => (
                        <div key={name} onClick={() => { setSelectedBall(name); setSearchTerm(''); }} className="px-4 py-2 text-white hover:bg-slate-700 cursor-pointer">
                          {name}
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                <div className="bg-slate-800 rounded-lg overflow-y-auto overflow-x-hidden" style={{ maxHeight: '80vh' }}>
                  <svg
                    width={svgWidth}
                    height={svgHeight}
                    viewBox={`0 0 ${svgWidth} ${svgHeight}`}
                    className="bg-slate-700"
                    style={{ minHeight: '900px', display: 'block' }}
                  >
                    <defs>
                      <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#94a3b8" />
                      </marker>
                    </defs>

                    {uniqueEvos.map((evo, idx) => {
                      const endPos = positions[evo.name];
                      if (!endPos) return null;

                      return evo.ingredients.map((ing, ingIdx) => {
                        const startPos = positions[ing];
                        if (!startPos) return null;
                        
                        const isHighlighted = selectedBall && (selectedBall === evo.name || selectedBall === ing || evo.ingredients.includes(selectedBall));

                        return (
                          <line
                            key={`line-${idx}-${ingIdx}`}
                            x1={startPos.x + baseWidth}
                            y1={startPos.y + baseHeight / 2}
                            x2={endPos.x}
                            y2={endPos.y + baseHeight / 2}
                            stroke={isHighlighted ? '#3b82f6' : '#64748b'}
                            strokeWidth={isHighlighted ? 2 : 1}
                            markerEnd="url(#arrowhead)"
                            opacity={isHighlighted ? 1 : 0.4}
                            className="transition-all"
                          />
                        );
                      });
                    })}

                    {baseElements.map((element) => {
                      const pos = positions[element];
                      if (!pos) return null;
                      const isSelected = selectedBall === element;
                      const isConnected = evolutions.some(
                        e => (e.name === selectedBall && e.ingredients.includes(element)) ||
                             (e.ingredients.includes(selectedBall) && e.name === element)
                      );

                      return (
                        <g key={`base-${element}`}>
                          <rect
                            x={pos.x} y={pos.y} width={baseWidth} height={baseHeight} rx="4"
                            fill={getColor(element)}
                            stroke={isSelected ? '#fff' : isConnected && selectedBall ? '#3b82f6' : 'none'}
                            strokeWidth={isSelected ? 2 : isConnected && selectedBall ? 1.5 : 0}
                            opacity={!selectedBall || isSelected || isConnected ? 1 : 0.3}
                            className="cursor-pointer transition-all hover:opacity-100"
                            onClick={() => setSelectedBall(selectedBall === element ? null : element)}
                            onMouseEnter={() => setHoveredNode(element)}
                            onMouseLeave={() => setHoveredNode(null)}
                          />
                          <NodeContent name={element} pos={pos} />
                        </g>
                      );
                    })}

                    {uniqueEvos.map((evo, idx) => {
                        const pos = positions[evo.name];
                        if (!pos) return null;
                        const isSelected = selectedBall === evo.name;
                        const isConnected = evolutions.some(
                          e => (e.name === selectedBall && e.ingredients.includes(evo.name)) ||
                               (e.ingredients.includes(selectedBall) && e.name === evo.name)
                        );

                        return (
                          <g key={`evo-${evo.name}-${idx}`}>
                            <rect
                              x={pos.x} y={pos.y} width={baseWidth} height={baseHeight} rx="4"
                              fill={getColor(evo.name)}
                              stroke={isSelected ? '#fff' : isConnected && selectedBall ? '#3b82f6' : 'none'}
                              strokeWidth={isSelected ? 2 : isConnected && selectedBall ? 1.5 : 0}
                              opacity={!selectedBall || isSelected || isConnected ? 1 : 0.3}
                              className="cursor-pointer transition-all hover:opacity-100"
                              onClick={() => setSelectedBall(selectedBall === evo.name ? null : evo.name)}
                              onMouseEnter={() => setHoveredNode(evo.name)}
                              onMouseLeave={() => setHoveredNode(null)}
                            />
                            <NodeContent name={evo.name} pos={pos} />
                          </g>
                        );
                    })}
                  </svg>
                </div>

                {activeNode && (
                  <div className="mt-4 bg-slate-800 rounded-lg p-4 max-w-md">
                    <h3 className="text-white font-semibold mb-2">{activeNode}</h3>
                    {recipesForActiveNode.length > 0 ? (
                      <div className="text-slate-300 text-sm">
                        {recipesForActiveNode.map((recipe, i) => (
                          <div key={i}>{recipe}</div>
                        ))}
                      </div>
                    ) : null}
                  </div>
                )}
              </div>
            </div>
          );
        }

        ReactDOM.render(<BallEvolutionGraph />, document.getElementById('root'));
    </script>
</body>
</html>